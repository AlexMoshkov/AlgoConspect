---
cards-deck: Алгоритмы и структуры данных
---
### Модель и изменение времени

#### RAM-модель #card
Random Access Machine (RAM)
- Алгоритм -- программа написаная на RAM
- Ввод может быть произвольно большой длины
- Элементарные операторы выполняются за единицу времени
- Можно выделять массивы произвольной длины
- Чтение/запись элемента массива выполняется за единицу времени (*random access memory*, RAM) 
- Индексы массивов (числа от $0$ до $n-1$) занимают $\ge \log_2n$ битов (`int` в псевдокоде - не 32 бита и не 64)
^1654516608748

#### Время работы алгоритма #card
Время работы $t(A)$ -- число единиц времени, которое алгоритм тратит на завершение работы на входных данных $A$
##### Время работы алгоритма в худшем случае
$T(n) = max\{t(A) : A \in I_n\}$, где $I_n$ - это множество входов алгоритма размера $n$
$T(n, m) = max\{t(A) : A \in I_{n, m}\}$, где $I_n$ - это множество входов, заданных размерами $n$, и $m$.
^1654516352601

#### Ассимптотические оценки #card
Время работы измеряют ассимптотически
Алгоритм работает за время $\Theta(f(n))$, если время работы алгоритма в худшем случае равно $\Theta(f(n))$
^1654516571619

#### O-символика #card
- $g(n) \in O(f(n))$, если для некоторого $c_g > 0$ и $n_g$ выполняется $g(n) \le c_g \cdot f(n)$ при $n > n_g$
- $g(n) \in \Omega(f(n))$, если для некоторого $c_g > 0$ и $n_g$ выполняется $g(n) \ge c_g \cdot f(n)$ при $n > n_g$
- $g(n) \in \Theta(f(n))$, если $g(n) \in O(f(n))$ и $g(n) \in \Omega(f(n))$
- $g(n) \in o(f(n))$, если $\lim\limits_{n \to \infty} \frac{g(n)}{f(n)} = 0$
- $g(n) \in \omega(f(n))$, если $\lim\limits_{n \to \infty} \frac{g(n)}{f(n)} = \infty$
^1654516352720

#### Как оценивать сложность рекурсивных алгоритмов #card
1. В каждом узле указываем, сколько времени алгоритм потратил на нем
2. На каждом уровне дерева суммируем время из узлов
3. Общее время -- сумма времени на всех уровнях
![[20220607111712.png]]
Для сортировки слиянием получаем $T(n) \le cn\log n$
^1654582884212

#### Оптимальное время работы #card 
Алгоритм с временем работы $O(f(n))$ называется оптимальным, если любой алгоритм для данной задачи обязательно должен тратить время $\Omega(f(n))$ в худшем случае на входе размера $n$
Время $\Theta(f(n))$ называется оптимальным
Цель -- найти оптимальный алгоритм
^1654582027389

#### Линейное время #card
Алгоритм, который на входных данных размера $n$ работает за $O(n)$ -- линейный	
^1654582027490

#### Лас-Вегас и Монте-Карло #card
- Вероятностный алгоритм, который всегда возвращает корректный результат -- **Лас-Вегас алгоритм**
- Вероятностный алгоритм, который иногда возвращает некорректный результат с какой-то малой вероятностью -- **Монте-Карло алгоритм**
`QuickSort` - Лас-Вегас алгоритм с матожиданием времени работы $O(n \log n)$
^1654583087778
